using FurnitureFramework.Data.FType;
using Microsoft.Xna.Framework.Content;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using StardewModdingAPI;

namespace FurnitureFramework.Data.FPack
{
	[JsonConverter(typeof(PackJsonConverter))]
	public partial class FPack
	{

		// Constants

		const string DEFAULT_PATH = "content.json";
		const string CONFIG_PATH = "config.json";

		// Static Collections 

		static public readonly Dictionary<string, IContentPack> ContentPacks = new();
		// UIDs of all Furniture Packs (for reload all).
		static readonly Dictionary<string, FPack> PacksData = new();
		// maps data_UID to pack.
		static readonly Dictionary<string, string> TypesOrigin = new();
		// maps type_id to the data_UID of the pack where it's defined.
		static readonly Dictionary<string, HashSet<string>> LoadedAssets = new();
		// a set of what asset names were loaded by each pack UID.
		static public readonly HashSet<string> AddedCatalogues = new();
		// a set of shops that were generated by FF on the Catalogue template.

		static IContentPack DefaultPack;

		// Pack Properties
		[JsonIgnore]
		LoadData LoadData_;
		[JsonIgnore]
		string UID { get => LoadData_.UID; }
		[JsonIgnore]
		public string DataUID { get => LoadData_.DataUID; }
		[JsonIgnore]
		readonly PackConfig Config = new();

		public int Format;
		public Dictionary<string, FType.FType> Furniture = new();
		public Dictionary<string, LoadData> Included = new();

		[JsonIgnore]
		public Dictionary<string, FPack> IncludedPacks = new();

		[JsonIgnore]
		FPack? Root = null;
		[JsonIgnore]
		bool IsIncluded { get => Root != null; }

		public void SetSource(LoadData load_data)
		{
			LoadData_ = load_data;
			if (load_data.Parent != null)
			{
				if (load_data.Parent.Root == null)
					Root = load_data.Parent;
				else
					Root = load_data.Parent.Root;
			}

			LoadConfig();

			foreach (string id in Furniture.Keys.ToList())
			{
				FType.FType f_type = Furniture[id];
				Furniture.Remove(id);
				f_type.SetIDs(UID, id);

				foreach (Variant var_data in f_type.Variants.Values)
				{
					Config.AddType(var_data.ID, var_data.GetVariantString(f_type.DisplayName, load_data.ContentPack));
					Furniture[var_data.ID] = f_type;
				}
			}

			foreach (string name in Included.Keys)
			{
				LoadData data = Included[name];
				data.ContentPack = load_data.ContentPack;
				data.Name = name;
				data.Parent = this;
				Config.AddIPack(data);

				FPack? i_pack = data.Load();
				if (i_pack == null) {
					ModEntry.Log($"Failed to load {data.Path}, skipping included pack.", LogLevel.Warn);
					continue;
				}
				
				IncludedPacks.Add(i_pack.DataUID, i_pack);
			}
			
			if (Furniture.Count == 0 && Included.Count == 0)
				ModEntry.Log("This Furniture Pack is empty!", LogLevel.Warn);
		}
	}

	class InvalidPack : FPack
	{
		Exception exception;

		public InvalidPack(Exception exception)
		{
			this.exception = exception;
		}

		public void Log()
		{
			if (exception is OutdatedFormatError format_error) format_error.Log();
			else ModEntry.Log(exception.Message, LogLevel.Error);
			ModEntry.Log("Skipping Furniture Pack.", LogLevel.Warn);

			if (exception.StackTrace != null)
				ModEntry.Log(exception.StackTrace, LogLevel.Trace);
		}
	}

	class OutdatedFormatError : Exception
	{
		int format;

		public OutdatedFormatError(int format)
		{
			this.format = format;
		}

		public void Log()
		{
			ModEntry.Log($"Format {format} is outdated!", LogLevel.Error);
			ModEntry.Log("If you are a user, wait for an update for this Furniture Pack,", LogLevel.Info);
			ModEntry.Log($"or use a version of the Furniture Framework starting with {format}.", LogLevel.Info);
			ModEntry.Log("If you are the author, check the Changelogs in the documentation to update your Pack.", LogLevel.Info);
		}
	}

	class PackJsonConverter : ReadOnlyConverter<FPack>
	{
		const int FORMAT = 3;

		public override FPack? ReadJson(JsonReader reader, Type objectType, FPack? existingValue, bool hasExistingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.StartObject)
			{
				JObject obj = JObject.Load(reader);

				FPack result = new();

				try { result.Format = CheckFormat(obj); }
				catch (Exception e) { return new InvalidPack(e); }

				ParseDict(obj, "Furniture", result.Furniture);
				ParseDict(obj, "Included", result.Included);

				return result;
			}

			return new InvalidPack(new InvalidDataException($"Furniture Pack data is Invalid."));
		}

		static int CheckFormat(JObject obj)
		{
			if (!obj.TryGetValue("Format", out JToken? format_token))
				throw new InvalidDataException("Missing Format!");
			if (format_token.Type != JTokenType.Integer)
				throw new InvalidDataException("Invalid Format!");

			int format = format_token.Value<int>();

			return format switch
			{
				FORMAT => format,
				< FORMAT and > 0 => throw new OutdatedFormatError(format),
				_ => throw new InvalidDataException("Invalid Format!"),
			};
		}

		static void ParseDict<TValue>(JObject pack_obj, string key, Dictionary<string, TValue> dictionary)
		{
			if (pack_obj.TryGetValue(key, out JToken? token) && token is JObject dict)
			{
				foreach (JProperty prop in dict.Properties())
				{
					if (prop.Value is JObject obj)
					{
						try
						{
							TValue data = obj.ToObject<TValue>() ?? throw new NullReferenceException("Value is null.");
							dictionary.Add(prop.Name, data);
						}
						catch (Exception e)
						{
							if (e is System.Reflection.TargetInvocationException && e.InnerException != null) e = e.InnerException;
							ModEntry.Log($"Could not parse value of \"{key}\" -> \"{prop.Name}\", skipping.", LogLevel.Warn);
							ModEntry.Log($"Reason: {e.Message}", LogLevel.Warn);
							if (e.StackTrace != null) ModEntry.Log(e.StackTrace, LogLevel.Trace);
						}
					}
				}
			}
		}
	}
}